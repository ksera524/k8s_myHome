# Harbor設定を定期的に修正するCronJob
# ArgoCDの自動同期で設定が戻ってしまう問題に対処
apiVersion: batch/v1
kind: CronJob
metadata:
  name: harbor-config-fix
  namespace: harbor
spec:
  schedule: "0 */6 * * *"  # 6時間ごとに実行（必要最小限）
  successfulJobsHistoryLimit: 0  # 成功したJobは即座に削除
  failedJobsHistoryLimit: 1
  concurrencyPolicy: Forbid  # 同時実行を禁止
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: harbor-config-fix
          restartPolicy: OnFailure
          containers:
          - name: fix-config
            image: bitnami/kubectl:latest
            command:
            - /bin/bash
            - -c
            - |
              set -e
              echo "=== Harbor Configuration Fix Starting at $(date) ==="
              NEED_RESTART=false
              
              # 1. Harbor ConfigMapのEXT_ENDPOINTを確認と修正
              CURRENT_CM=$(kubectl get cm harbor-core -n harbor -o jsonpath='{.data.EXT_ENDPOINT}' 2>/dev/null)
              if [ "$CURRENT_CM" != "http://harbor.local" ]; then
                echo "Fixing ConfigMap EXT_ENDPOINT from '$CURRENT_CM' to 'http://harbor.local'"
                kubectl patch cm harbor-core -n harbor --type json -p '[{"op": "replace", "path": "/data/EXT_ENDPOINT", "value": "http://harbor.local"}]'
                NEED_RESTART=true
              fi
              
              # 2. Deploymentに環境変数を直接追加（ConfigMapより優先される）
              echo "Checking Deployment environment variables..."
              
              # 既存のenv配列を確認
              HAS_ENV=$(kubectl get deployment harbor-core -n harbor -o jsonpath='{.spec.template.spec.containers[0].env}' 2>/dev/null)
              
              if [ -z "$HAS_ENV" ] || [ "$HAS_ENV" = "[]" ]; then
                # env配列が存在しない、または空の場合
                echo "Adding environment variables to deployment..."
                kubectl patch deployment harbor-core -n harbor --type json -p '[
                  {"op": "add", "path": "/spec/template/spec/containers/0/env", "value": [
                    {"name": "EXT_ENDPOINT", "value": "http://harbor.local"}
                  ]}
                ]'
                NEED_RESTART=true
              else
                # EXT_ENDPOINTが存在するか確認
                CURRENT_ENV=$(kubectl get deployment harbor-core -n harbor -o jsonpath='{.spec.template.spec.containers[0].env[?(@.name=="EXT_ENDPOINT")].value}' 2>/dev/null)
                if [ -z "$CURRENT_ENV" ]; then
                  # EXT_ENDPOINTが存在しない場合、追加
                  echo "Adding EXT_ENDPOINT to existing environment variables..."
                  kubectl patch deployment harbor-core -n harbor --type json -p '[
                    {"op": "add", "path": "/spec/template/spec/containers/0/env/-", "value": 
                      {"name": "EXT_ENDPOINT", "value": "http://harbor.local"}
                    }
                  ]'
                  NEED_RESTART=true
                elif [ "$CURRENT_ENV" != "http://harbor.local" ]; then
                  # 値が異なる場合、パッチで修正
                  echo "Fixing EXT_ENDPOINT environment variable from '$CURRENT_ENV' to 'http://harbor.local'"
                  # 直接YAMLを編集して適用
                  kubectl get deployment harbor-core -n harbor -o yaml | \
                    sed 's|name: EXT_ENDPOINT$|name: EXT_ENDPOINT|; /name: EXT_ENDPOINT/!b; n; s|value:.*|value: "http://harbor.local"|' | \
                    kubectl apply -f -
                  NEED_RESTART=true
                fi
              fi
              
              # 3. 必要に応じて再起動
              if [ "$NEED_RESTART" = "true" ]; then
                echo "Restarting Harbor core deployment..."
                kubectl rollout restart deployment/harbor-core -n harbor
                kubectl rollout status deployment/harbor-core -n harbor --timeout=120s || true
              fi
              
              # 4. harbor-auth secretも確認
              HARBOR_URL=$(kubectl get secret harbor-auth -n arc-systems -o jsonpath='{.data.HARBOR_URL}' 2>/dev/null | base64 -d)
              if [ "$HARBOR_URL" != "harbor.local" ]; then
                echo "Fixing harbor-auth secret"
                HARBOR_PASSWORD=$(kubectl get secret harbor-admin-secret -n harbor -o jsonpath='{.data.password}' 2>/dev/null | base64 -d)
                if [ -n "$HARBOR_PASSWORD" ]; then
                  kubectl create secret generic harbor-auth \
                    --namespace=arc-systems \
                    --from-literal=HARBOR_URL="harbor.local" \
                    --from-literal=HARBOR_USERNAME="admin" \
                    --from-literal=HARBOR_PASSWORD="${HARBOR_PASSWORD}" \
                    --from-literal=HARBOR_PROJECT="sandbox" \
                    --dry-run=client -o yaml | kubectl apply -f -
                fi
              fi
              
              echo "=== Harbor Configuration Fix Complete at $(date) ==="
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: harbor-config-fix
  namespace: harbor
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: harbor-config-fix
rules:
- apiGroups: [""]
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list", "patch", "update", "create"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "patch"]
- apiGroups: ["apps"]
  resources: ["deployments/status"]
  verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: harbor-config-fix
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: harbor-config-fix
subjects:
- kind: ServiceAccount
  name: harbor-config-fix
  namespace: harbor